require 'rest-client'
require 'json'
require 'active_support/core_ext/hash/keys'
require 'active_support/core_ext/string/inflections'

module QAT
	module Reporter
		class Opentest
			# QAT::Reporter::Xray::Publisher integrator module
			module Publisher
				# QAT::Reporter::Xray::Publisher::Base integrator class
				class Base
					attr_reader :base_url, :session_id, :environment, :actor_tags, :tests, :session_label, :bearer, :evidences
					
					# Initializes Xray Publisher url and login information
					def initialize
						@base_url      = QAT::Reporter::Opentest::Config.open_test_url
						@session_id    = QAT::Reporter::Opentest::Config.session_id
						@environment   = QAT::Reporter::Opentest::Config.environment
						@actor_tags    = QAT::Reporter::Opentest::Config.actor_tags
						@tests         = QAT::Reporter::Opentest::Config.tests
						@session_label = QAT::Reporter::Opentest::Config.session_label
						@bearer        = QAT::Reporter::Opentest::Config.bearer
						@evidences     = QAT::Reporter::Opentest::Config.evidences
					end
					
					# REST Base Client implementation
					class Client
						
						# Service Unavailable Error class
						class ServiceUnavailableError < StandardError
						end
						
						# Connection Error class
						class ConnectionError < StandardError
						end
						
						# No Connection Error class
						class NoConnectionFound < StandardError
						end
						
						class NoTestsFound < StandardError
						end
						
						attr_reader :base_uri
						
						# Returns a new REST Base Client
						# @return [RestClient::Response]
						def initialize(base_uri)
							# sets the ip:port/base_route
							@base_uri = case base_uri
														when Hash
															URI::HTTP.build(base_uri).to_s
														when URI::HTTP
															base_uri.to_s
														when String
															base_uri
														else
															raise ArgumentError.new "Invalid URI class: #{base_uri.class}"
													end
						end
						
						[:put, :post, :get, :delete, :patch].each do |operation|
							define_method operation do |url, *args|
								final_url = base_uri + url
								puts final_url
								log_request operation, final_url, args
								# begin
								response = RestClient.method(operation).call(final_url, *args)
								log_response response
								# 	validate response
								# rescue RestClient::ExceptionWithResponse => e
								# 	raise NoTestsFound.new ('Tests were not found!!!')
								# rescue => exception
								# 	puts "#{exception.class} #{exception.message.to_s}"
								# 	raise NoConnectionFound.new ('TEST was not found!!!')
								# end
							end
						end
						
						protected
						
						# Validates the response and raises a HTTP Error
						#@param response [RestClient::Response] response
						def validate(response)
							error_klass = case response.code
															when 400 then
																Error::BadRequest
															when 401 then
																Error::Unauthorized
															when 403 then
																Error::Forbidden
															when 404 then
																Error::NotFound
															when 405 then
																Error::MethodNotAllowed
															when 409 then
																Error::Conflict
															when 422 then
																Error::Unprocessable
															when 500 then
																Error::InternalServerError
															when 502 then
																Error::BadGateway
															when 503 then
																Error::ServiceUnavailable
														end
							
							raise error_klass.new response if error_klass
							response
						end
						
						# Logs the request information
						#@param operation [String] HTTP operation called
						#@param url [String] target URL
						#@param args [String] request arguments
						#@see RestClient#get
						def log_request(operation, url, args)
							puts { "#{operation.upcase}: #{url}" }
							
							args.each do |options|
								log_http_options options
							end
						end
						
						# Logs the received response
						#@param response [RestClient::Response] response
						def log_response(response)
							puts "Response HTTP #{response.code} (#{response.body})"
							
							log_http_options({ body: response.body }.select { |_, value| !value.nil? })
						end
						
						# Logs the request's HTTP options
						#@param options [Hash|String] http options to log
						def log_http_options(options)
							temp = if options.is_a?(String)
											 { payload: JSON.parse(options) }
										 else
											 options.map do |k, v|
												 if k == :body
													 begin
														 [k, JSON.pretty_generate(JSON.parse(v))]
														 # if body is not JSON by some unknown reason, we still want to print
													 rescue JSON::ParserError
														 [k, v]
													 end
												 else
													 [k, v]
												 end
											 end.to_h
										 end
							
							temp.each do |key, value|
								puts "#{key.to_s.humanize}:"
								puts value
							end
						end
					
					end
				end
			end
		end
	end
end